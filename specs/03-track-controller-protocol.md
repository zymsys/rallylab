# RallyLab â€” Track Controller Protocol

**Version:** 1.0
**Status:** Specification

---

Goal: a youth-friendly, hackable protocol that works over **WiFi (HTTP GET)** and **USB (serial text commands)** with the **same semantics**.

Core concept: the Track Controller publishes the **last completed race**. Clients can:

- fetch it immediately (`state`)
- long-poll until a new race completes (`wait`)

Each completed race has a **race\_id** (UUID string) generated by the Track Controller.

All responses are **pretty-printed JSON**.

---

## 1. Transport Overview

### 1.1 WiFi Transport (HTTP)

- The device runs an HTTP server.
- All endpoints use **GET**.

### 1.2 USB Transport (Serial)

- The device exposes a USB CDC serial port.
- Baud rate: **115200**
- Requests are ASCII text lines terminated by `\n` (LF). `\r\n` is accepted.
- One response is produced per request.

**Cancel rule (important):**

> While the device is blocked in a `wait`, **any incoming line** cancels the wait and is treated as the next command.

---

## 2. Response Conventions

### 2.1 Success

Success responses return a **JSON object** (no wrapper).

### 2.2 Errors

Errors return a JSON object of the form:

```json
{
  "error": "human readable message"
}
```

---

## 3. Data Types

### 3.1 Time Units

- The protocol does not report absolute timestamps.
- All lane times are **milliseconds since race start**.

### 3.2 Lane Selection String (`lanes`)

A compact string of lane numbers, e.g.:

- `"123456"` = all lanes 1-6
- `"36"` = lanes 3 and 6 only

Rules:

- Digits MUST be unique.
- Each digit MUST be within `1..lane_count`.
- Order SHOULD be ascending for readability, but implementations MAY accept any order.

### 3.3 Times Map (`times_ms`)

A JSON object mapping lane number strings to lane times.

- Keys are lane numbers as strings: `"1"`, `"2"`, ...
- Values are integers (milliseconds).
- **No nulls.** If a lane is not used for a race, it is simply **absent**.

Example:

```json
{
  "3": 2401,
  "6": 2603
}
```

---

## 4. Endpoints and Commands

### 4.1 `info` (Capabilities)

Use this once at Race Controller initialization.

#### HTTP

`GET /info`

#### Serial

`info`

#### Response

```json
{
  "protocol": "1.0",
  "firmware": "<string>",
  "lane_count": 6
}
```

---

### 4.2 `state` (Last Completed Race)

`state` returns the same shape as a `wait` response, but for the **last completed** race.

#### HTTP

`GET /state`

#### Serial

`state`

#### Response

If a race has completed since boot:

```json
{
  "race_id": "550e8400-e29b-41d4-a716-446655440000",
  "times_ms": {
    "1": 2150,
    "2": 2320,
    "4": 3010,
    "5": 2875,
    "6": 2601
  }
}
```

If no race has completed since boot:

```json
null
```

---

### 4.3 `wait_race` (Block Until Next Completed Race)

#### HTTP

`GET /wait/race[?after=<race_id>][&lanes=<lanes>]`

#### Serial

Accept either form:
- `wait/race[ after=<race_id>][ lanes=<lanes>]`
- `wait_race[ after=<race_id>][ lanes=<lanes>]`
- `wait/race[?after=<race_id>][&lanes=<lanes>]`

Parameters:
- `after` (optional)
  - The last completed `race_id` the client has seen.
  - If `after` is **missing**, the call **always blocks** until a race completes.
- `lanes` (optional)
  - Declares which lanes count for the *next* race completion **only if** the engine is currently idle/armed.
  - Omit to use the default (all lanes).

#### Behavior

- If `after` is provided and does NOT equal the current last completed `race_id`, return immediately with the last completed race.
- If `after` equals the current last completed `race_id` (or is missing), block until a race completes, then return.

#### Response

```json
{
  "race_id": "550e8400-e29b-41d4-a716-446655440002",
  "times_ms": {
    "3": 2401,
    "6": 2603
  }
}
```

---

### 4.4 `gate` (Start Gate Readiness)

The Race Controller needs to know when the start gate has been **reset** (returned to the ready state for the next heat).

This is exposed as a simple, high-level boolean: `gate_ready`.

#### HTTP

`GET /gate`

#### Serial

`gate`

#### Response

```json
{
  "gate_ready": true
}
```

---

### 4.5 `wait_gate` (Block Until Gate Becomes Ready)

After showing race results, the Race Controller can block until the gate is reset.

#### HTTP

`GET /wait/gate`

#### Serial

Accept either form:
- `wait/gate`
- `wait_gate`

#### Behavior

- If the gate is already ready, return immediately.
- Otherwise, block until `gate_ready` becomes `true`, then return.

#### Response

```json
{
  "gate_ready": true
}
```

---

### 4.6 `dbg` (Debug Snapshot)

Debug is read-only and may evolve. Intended for wiring, sensor, and state-machine diagnosis.

#### HTTP

`GET /dbg`

#### Serial

`dbg`

#### Response (suggested)

```json
{
  "controller": {
    "protocol": "1.0",
    "firmware": "<string>",
    "uptime_ms": 123456
  },
  "wifi": {
    "mode": "sta",
    "ssid": "<string>",
    "ip": "192.168.1.50",
    "rssi": -61
  },
  "io": {
    "start_gate": {
      "raw": 1,
      "debounced": 1,
      "invert": false,
      "pull": "up",
      "last_edge_ms": 1700000000123
    },
    "lanes": {
      "1": { "raw": 0, "debounced": 0, "invert": false, "pull": "up", "last_edge_ms": 1700000000456 },
      "2": { "raw": 0, "debounced": 0, "invert": false, "pull": "up", "last_edge_ms": 1700000000456 }
    },
    "debounce_ms": 10
  },
  "engine": {
    "phase": "IDLE",
    "armed": false,
    "lanes_default": "123456"
  }
}
```

---

## 5. Implementation Notes (Non-Normative)

- Consider limiting concurrent HTTP `/wait` clients to a small fixed number (e.g., 8 or 16) to protect RAM. If exceeded, return:

```json
{
  "error": "too many wait clients"
}
```

- For serial, the cancel rule provides a natural way to stop waiting without timeouts.
- Pretty JSON should be streamed when possible (avoid building large strings in RAM).

---

**End of Track Controller Protocol v1.0**
